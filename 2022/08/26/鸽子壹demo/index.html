<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="John Doe">







<title>golang底层笔记 | DoveOne</title>



    <link rel="icon" href="/pigeon.ico">



<style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans+SC:wght@300;400;500;700&family=Roboto+Mono&display=swap');
</style>



    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    




    <!-- scripts list from _config.yml -->
    
    <script src="/js/frame.js"></script>
    










  <meta name="generator" content="Hexo 6.1.0"></head>
  <body>
    <div class="mask-border">
    </div>

    <div class="wrapper">

      <div class="header">
  <div class="flex-container">
    <div class="header-inner">
      <div class="site-brand-container">
        <a href="/">
          
            DevoOne.
          
        </a>
      </div>
      <div id="menu-btn" class="menu-btn" onclick="toggleMenu()">
        Menu
      </div>
      <nav class="site-nav">
        <ul class="menu-list">
          
            
              <li class="menu-item">
                <a href="/">Home</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/archives/">Archive</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/about">About</a>
              </li> 
                   
          
        </ul>
      </nav>
    </div>
  </div>
</div>


      <div class="main">
        <div class="flex-container">
          <article id="post">

  
    <div class="post-head">
    <div class="post-info">
        <div class="tag-list">
            
                
                    <span class="post-tag">
                        <a href="/tags/golang/">
                            golang
                        </a>
                    </span>    
                           
            
        </div>
        <div class="post-title">
            
            
                golang底层笔记
            
            
        </div>
        <span class="post-date">
            Aug 26, 2022
        </span>
    </div>
    <div class="post-img">
        
            <div class="h-line-primary"></div>
              
    </div>
</div>
    <div class="post-content">
    <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1linux%E6%8C%87%E4%BB%A4">1.Linux指令</a><ul>
<li><a href="#%E8%A7%A3%E5%8E%8B%E6%8C%87%E4%BB%A4">解压指令</a></li>
</ul>
</li>
<li><a href="#2%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">2.基本数据结构</a><ul>
<li><a href="#%E5%AD%97%E8%8A%82%E5%92%8C%E7%A9%BA%E7%BB%93%E6%9E%84%E4%BD%93">字节和空结构体</a></li>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2">字符串</a></li>
<li><a href="#%E5%88%87%E7%89%87">切片</a></li>
<li><a href="#hashmap">HashMap</a></li>
<li><a href="#map%E6%89%A9%E5%AE%B9">map扩容</a></li>
<li><a href="#%E6%8E%A5%E5%8F%A3">接口</a></li>
<li><a href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E6%8C%87%E9%92%88%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3">结构体和指针实现接口</a></li>
<li><a href="#%E7%A9%BA%E6%8E%A5%E5%8F%A3">空接口</a></li>
<li><a href="#nil%E7%A9%BA%E6%8E%A5%E5%8F%A3%E7%A9%BA%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%8C%BA%E5%88%AB">nil,空接口，空结构体的区别</a></li>
<li><a href="#%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90">内存对齐</a></li>
</ul>
</li>
<li><a href="#3goroutine%E5%8D%8F%E7%A8%8B">3.Goroutine协程</a><ul>
<li><a href="#%E5%8D%8F%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8Bgm%E7%BB%93%E6%9E%84%E4%BD%93">协程和线程(g,m结构体)</a></li>
<li><a href="#%E7%BA%BF%E7%A8%8B%E5%BE%AA%E7%8E%AF">线程循环</a></li>
<li><a href="#gmp%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B">*GMP调度模型</a></li>
<li><a href="#%E5%8D%8F%E7%A8%8B%E9%A5%A5%E9%A5%BF%E9%97%AE%E9%A2%98">协程饥饿问题</a></li>
<li><a href="#%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98">抢占式调度解决了什么问题</a></li>
<li><a href="#%E5%8D%8F%E7%A8%8B%E8%BF%87%E5%A4%9A">协程过多</a></li>
</ul>
</li>
<li><a href="#4sync%E9%94%81">4.sync(锁…)</a><ul>
<li><a href="#atomic%E6%93%8D%E4%BD%9C">atomic操作</a></li>
<li><a href="#sema%E9%94%81">*sema锁</a></li>
<li><a href="#%E4%BA%92%E6%96%A5%E9%94%81">互斥锁</a></li>
<li><a href="#%E8%AF%BB%E5%86%99%E9%94%81">读写锁</a></li>
<li><a href="#waitgroup">WaitGroup</a></li>
<li><a href="#once">Once</a></li>
<li><a href="#%E9%94%81%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98">锁常见问题</a></li>
</ul>
</li>
<li><a href="#5channel">5.Channel</a><ul>
<li><a href="#%E5%86%85%E5%AD%98%E4%B8%8E%E9%80%9A%E4%BF%A1">内存与通信</a></li>
<li><a href="#%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84">底层结构</a></li>
<li><a href="#c-%E5%92%8C-c%E5%85%B3%E9%94%AE%E5%AD%97">c&lt;- 和&lt;-c关键字</a></li>
<li><a href="#channel%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86">Channel发送数据的底层原理</a></li>
<li><a href="#channel%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86">Channel接收数据的底层原理</a></li>
<li><a href="#%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%9A%84channelselecttimer">非阻塞的Channel(select,timer)</a></li>
</ul>
</li>
<li><a href="#6tcp%E7%BD%91%E8%B7%AF%E7%BC%96%E7%A8%8B">6.TCP网路编程</a><ul>
<li><a href="#io%E6%A8%A1%E5%9E%8B">IO模型</a></li>
<li><a href="#go%E6%8A%BD%E8%B1%A1epoll">go抽象epoll</a></li>
<li><a href="#socket">Socket</a></li>
<li><a href="#%E7%BB%93%E5%90%88%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8">结合阻塞模型和多路复用</a></li>
</ul>
</li>
<li><a href="#7%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6">7.内存模型与垃圾回收</a><ul>
<li><a href="#%E5%8D%8F%E7%A8%8B%E6%A0%88">协程栈</a></li>
<li><a href="#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90">逃逸分析</a></li>
<li><a href="#%E6%A0%88%E6%89%A9%E5%AE%B9">栈扩容</a></li>
<li><a href="#%E5%A0%86%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84">堆内存结构</a></li>
<li><a href="#%E5%A0%86%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D">堆内存分配</a></li>
<li><a href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6">垃圾回收</a></li>
<li><a href="#%E4%BC%98%E5%8C%96gc%E6%95%88%E7%8E%87">优化GC效率</a></li>
</ul>
</li>
<li><a href="#8go%E7%9A%84%E5%85%B6%E4%BB%96%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7">8.Go的其他高级特性</a><ul>
<li><a href="#go%E8%B0%83%E7%94%A8c%E4%BB%A3%E7%A0%81cgo">go调用c代码(cgo)</a></li>
<li><a href="#defer%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86">defer底层原理</a></li>
<li><a href="#panic-defer-recover">panic + defer +recover</a></li>
<li><a href="#reflect">reflect</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h3><span id="1linux指令">1.Linux指令</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ll /proc/PID 查看进程所在文件夹</span><br><span class="line">chmod +x usual_data_svc  给新换的包 添加权限  添加完 ll查看权限</span><br><span class="line">ps -ef | grep usual_data_svc  查看正在运行的进出</span><br><span class="line">killall usual_data_svc 杀掉之前进程</span><br><span class="line">补：cpu和内存指令</span><br></pre></td></tr></table></figure>

<h5><span id="解压指令">解压指令</span></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">1、.tar</span><br><span class="line"></span><br><span class="line">解包：tar xvf FileName.tar</span><br><span class="line"></span><br><span class="line">打包：tar cvf FileName.tar DirName</span><br><span class="line"></span><br><span class="line">（注：tar是打包，不是压缩！）</span><br><span class="line"></span><br><span class="line">2、.gz</span><br><span class="line"></span><br><span class="line">解压1：gunzip FileName.gz</span><br><span class="line"></span><br><span class="line">解压2：gzip -d FileName.gz</span><br><span class="line"></span><br><span class="line">压缩：gzip FileName</span><br><span class="line"></span><br><span class="line">3、.tar.gz 和 .tgz</span><br><span class="line"></span><br><span class="line">解压：tar zxvf FileName.tar.gz</span><br><span class="line"></span><br><span class="line">压缩：tar zcvf FileName.tar.gz DirName</span><br><span class="line"></span><br><span class="line">4、.bz2</span><br><span class="line"></span><br><span class="line">解压1：bzip2 -d FileName.bz2</span><br><span class="line"></span><br><span class="line">解压2：bunzip2 FileName.bz2</span><br><span class="line"></span><br><span class="line">压缩： bzip2 -z FileName</span><br><span class="line"></span><br><span class="line">5、.tar.bz2</span><br><span class="line"></span><br><span class="line">解压：tar jxvf FileName.tar.bz2</span><br><span class="line"></span><br><span class="line">压缩：tar jcvf FileName.tar.bz2 DirName</span><br><span class="line"></span><br><span class="line">6、.bz</span><br><span class="line"></span><br><span class="line">解压1：bzip2 -d FileName.bz</span><br><span class="line"></span><br><span class="line">解压2：bunzip2 FileName.bz</span><br><span class="line"></span><br><span class="line">压缩：未知</span><br><span class="line"></span><br><span class="line">7、.tar.bz</span><br><span class="line"></span><br><span class="line">解压：tar jxvf FileName.tar.bz</span><br><span class="line"></span><br><span class="line">压缩：未知</span><br><span class="line"></span><br><span class="line">8、.Z</span><br><span class="line"></span><br><span class="line">解压：uncompress FileName.Z</span><br><span class="line"></span><br><span class="line">压缩：compress FileName</span><br><span class="line"></span><br><span class="line">9、.tar.Z</span><br><span class="line"></span><br><span class="line">解压：tar Zxvf FileName.tar.Z</span><br><span class="line"></span><br><span class="line">压缩：tar Zcvf FileName.tar.Z DirName</span><br><span class="line"></span><br><span class="line">10、.zip</span><br><span class="line"></span><br><span class="line">解压：unzip FileName.zip</span><br><span class="line"></span><br><span class="line">压缩：zip FileName.zip DirName</span><br><span class="line"></span><br><span class="line">11、.rar</span><br><span class="line"></span><br><span class="line">解压：rar x FileName.rar</span><br><span class="line"></span><br><span class="line">压缩：rar a FileName.rar DirName</span><br><span class="line"></span><br><span class="line">12、.lha</span><br><span class="line"></span><br><span class="line">解压：lha -e FileName.lha</span><br><span class="line"></span><br><span class="line">压缩：lha -a FileName.lha FileName</span><br></pre></td></tr></table></figure>



<h3><span id="2基本数据结构">2.基本数据结构</span></h3><h4><span id="字节和空结构体">字节和空结构体</span></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">unsafe.Sizeof() 返回对象的字节数</span><br><span class="line">int 8</span><br><span class="line">int8 1 int16 2 int32 4 int64 8</span><br><span class="line">指针字节8</span><br><span class="line">空结构体有地址没长度</span><br><span class="line">独立的空结构体指向同一个地址（zerobase）</span><br><span class="line">1.空结构体的地址均相同（不被包含在其他结构体中）</span><br><span class="line">2.空结构体主要是为了节约内存</span><br><span class="line">  ①结合map（只想要键不想要值 hashset）</span><br><span class="line">   hashset //Key:null 有k无v</span><br><span class="line">   m := map[string]struct&#123;&#125;&#123;&#125;</span><br><span class="line">   m[&quot;a&quot;] = struct&#123;&#125;&#123;&#125;</span><br><span class="line">  ②结合channel（只想发信号不想携带信息 纯信号）</span><br><span class="line">   a:= make(chan struct&#123;&#125;)</span><br><span class="line">总结：</span><br><span class="line">1.go中部分数据的长度与系统字节有关（32 4 64 8）</span><br><span class="line">2.空结构体不占用空间</span><br><span class="line">3.空结构体与map结合可以实现hashset</span><br><span class="line">4.空结构体与channel结合可以当作纯信号</span><br></pre></td></tr></table></figure>



<h4><span id="字符串">字符串</span></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">type stringStruct struct &#123;</span><br><span class="line">	str unsafe.Pointer //指针 8字节 </span><br><span class="line">	len int            //int 8字节</span><br><span class="line">&#125;</span><br><span class="line">字符串类型16字节（8+8）</span><br><span class="line">Data指针指向底层Byte数组</span><br><span class="line">len表示Byte数组的长度而不是字符串 </span><br><span class="line">（对字符串使用len方法得到的是字节数不是字符数）</span><br><span class="line"></span><br><span class="line">* s=string([]rune(s)[:n])</span><br><span class="line">(先转为rune数组进行切分再转为string)</span><br><span class="line">func main() &#123;</span><br><span class="line">	a := &quot;鸽子1&quot;</span><br><span class="line">	s := string([]rune(a)[:3])</span><br><span class="line">	println(s)</span><br><span class="line">&#125;</span><br><span class="line">输出：鸽子1</span><br><span class="line"></span><br><span class="line">type byte = uint8</span><br><span class="line">type rune = int32</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4><span id="切片">切片</span></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">type slice struct &#123;</span><br><span class="line">	array unsafe.Pointer</span><br><span class="line">	len   int</span><br><span class="line">	cap   int</span><br><span class="line">&#125;</span><br><span class="line">切片类型24字节（8+8+8）</span><br><span class="line">切片扩容逻辑：</span><br><span class="line">1.如果新申请容量比两倍原有容量大，那么扩容后容量大小为新申请容量</span><br><span class="line">2.如果原有slice长度小于1024，那么每次就扩容为原来的2 倍</span><br><span class="line">3.如果原slice长度大于等于1024，那么每次扩容就扩为原来的1.25倍</span><br><span class="line"></span><br><span class="line">切片扩容时，并发不安全，注意切片并发要加锁</span><br></pre></td></tr></table></figure>



<h4><span id="hashmap">HashMap</span></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">Go中的map是一个指针，占用8个字节，指向hmap结构体</span><br><span class="line"></span><br><span class="line">1.开放寻址法</span><br><span class="line">2.拉链法</span><br><span class="line"></span><br><span class="line">type hmap struct &#123;</span><br><span class="line">    count     int </span><br><span class="line">    // 代表哈希表中的元素个数，调用len(map)时，返回的就是该字段值。</span><br><span class="line">    flags     uint8 </span><br><span class="line">    // 状态标志（是否处于正在写入的状态等）</span><br><span class="line">    B         uint8  </span><br><span class="line">    // buckets（桶）的对数</span><br><span class="line">    // 如果B=5，则buckets数组的长度 = 2^B=32，意味着有32个桶</span><br><span class="line">    noverflow uint16 </span><br><span class="line">    // 溢出桶的数量</span><br><span class="line">    hash0     uint32 </span><br><span class="line">    // 生成hash的随机数种子</span><br><span class="line">    buckets    unsafe.Pointer </span><br><span class="line">    // 指向buckets数组的指针，数组大小为2^B，如果元素个数为0，它为nil。</span><br><span class="line">    oldbuckets unsafe.Pointer </span><br><span class="line">    // 如果发生扩容，oldbuckets是指向老的buckets数组的指针，老的buckets数组大小是新的buckets的1/2;非扩容状态下，它为nil。</span><br><span class="line">    nevacuate  uintptr        </span><br><span class="line">    // 表示扩容进度，小于此地址的buckets代表已搬迁完成。</span><br><span class="line">    extra *mapextra </span><br><span class="line">    // 存储溢出桶，这个字段是为了优化GC扫描而设计的，下面详细介绍</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">// A bucket for a Go map.</span><br><span class="line">type bmap struct &#123;</span><br><span class="line">	tophash [bucketCnt]uint8 //bucketCnt = 8</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">初始化 1.make 2.字面量</span><br><span class="line">字面量初始化：①当元素少于25时，转化为简单赋值（调用make）</span><br><span class="line">             ②当元素多于25时，转化为循环赋值 </span><br><span class="line">             （声明map，kv两个数组，for循环赋值）</span><br><span class="line"></span><br><span class="line">·map的访问：计算桶号</span><br><span class="line">k+hash0 -&gt;haher(hash函数)-&gt;hash值</span><br><span class="line">根据b值取hash值二级制的后n位来确定桶号</span><br><span class="line">·map的访问：匹配</span><br><span class="line">tohash()取hash值二级制高八位计算tohash(十六进制)</span><br><span class="line">再去tohash数组遍历查对应的k是否对应-&gt;v</span><br><span class="line">如果找不到看overflow溢出指针去溢出桶找-&gt;V</span><br><span class="line">如果都没有则k对应v不存在 访问结束</span><br><span class="line"></span><br><span class="line">·map的写入，同上</span><br><span class="line">如果没有找到就插入新值</span><br><span class="line"></span><br><span class="line">总结：</span><br><span class="line">1.go语言使用拉链法实现了hashmap</span><br><span class="line">2.每一个桶中存储键哈希的前8位</span><br><span class="line">3.桶超过8个数据，就会存储到溢出桶中</span><br></pre></td></tr></table></figure>



<h4><span id="map扩容">map扩容</span></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">map的扩容</span><br><span class="line">1.map溢出桶太多时会导致严重的性能下降</span><br><span class="line">2.runtime.mapassign()可能会出发扩容的情况：</span><br><span class="line">  ①装载因子超过6.5(平均每个槽6.5个key)</span><br><span class="line">  ②使用了太多溢出桶(溢出桶超过了普通桶)</span><br><span class="line">  (装载因子 = 哈希表存储的元素个数/桶个数)</span><br><span class="line">  </span><br><span class="line">  Go 官方发现：装载因子越大，填入的元素越多，空间利用率就越高，但发生哈希冲突的几率就变大。根据测试结果和讨论，Go 官方取了一个相对适中的值，把 Go 中的 map 的负载因子硬编码为 6.5</span><br><span class="line">  </span><br><span class="line">map的扩容类型</span><br><span class="line">1.等量扩容：数据不多但是溢出桶太多了(整理)</span><br><span class="line">2.翻倍扩容：数据太多了</span><br><span class="line"></span><br><span class="line">map扩容：步骤1</span><br><span class="line">1.创建一组新通</span><br><span class="line">2.oldbuckets指向原有的桶数组</span><br><span class="line">3.buckets指向新的桶数组</span><br><span class="line">4.map标记为扩容状态</span><br><span class="line">map扩容：步骤2</span><br><span class="line">1.将所有的数据从旧桶驱逐道新桶</span><br><span class="line">2.采用渐进式驱逐</span><br><span class="line">3.每次操作一个旧桶时，将旧桶数据驱逐到新桶</span><br><span class="line">4.读取时不进行驱逐，只判断读取新桶还是旧桶</span><br><span class="line">map扩容：步骤3</span><br><span class="line">1.所以的旧桶驱逐完成后</span><br><span class="line">2.oldbuckets回收</span><br><span class="line"></span><br><span class="line">总结</span><br><span class="line">1.装载系数或者溢出桶的增加，会触发map扩容</span><br><span class="line">2.&quot;扩容&quot;可能斌不是增加桶数，而是整理</span><br><span class="line">3.map扩容采用渐进式，桶被操作时才会重新分配</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4><span id="接口">接口</span></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">type iface struct &#123;</span><br><span class="line">	tab  *itab</span><br><span class="line">	data unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type itab struct &#123;</span><br><span class="line">	inter *interfacetype</span><br><span class="line">	_type *_type</span><br><span class="line">	hash  uint32 </span><br><span class="line">	_     [4]byte</span><br><span class="line">	fun   [1]uintptr </span><br><span class="line">&#125;</span><br><span class="line">接口值的底层表示</span><br><span class="line">1.接口数据使用runtime.iface表示</span><br><span class="line">2.iface记录了数据的地址</span><br><span class="line">3.iface中也记录了接口类型信息和实现的方法</span><br><span class="line"></span><br><span class="line">(Go接口是隐式接口)</span><br><span class="line">Go隐式接口特点</span><br><span class="line">1.只要实现接口的所有方法，就是自动实现接口</span><br><span class="line">2，可以在不修改代码的情况下抽象出新的接口</span><br></pre></td></tr></table></figure>



<h4><span id="结构体和指针实现接口">结构体和指针实现接口</span></h4><table>
<thead>
<tr>
<th></th>
<th>结构体实现接口</th>
<th align="center">结构体指针实现接口</th>
</tr>
</thead>
<tbody><tr>
<td>结构体初始化变量</td>
<td>通过</td>
<td align="center">不通过</td>
</tr>
<tr>
<td>结构体指针初始化变量</td>
<td>通过</td>
<td align="center">通过</td>
</tr>
</tbody></table>
<p>（通过结构体实体实现接口，会自动帮你实现结构体指针实现接口的方法）</p>
<h4><span id="空接口">空接口</span></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type eface struct &#123;</span><br><span class="line">	_type *_type</span><br><span class="line">	data  unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line">空接口可以承载任何数据</span><br></pre></td></tr></table></figure>



<h4><span id="nil空接口空结构体的区别">nil,空接口，空结构体的区别</span></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// nil is a predeclared identifier representing the zero value for a</span><br><span class="line">// pointer, channel, func, interface, map, or slice type.</span><br><span class="line">var nil Type // Type must be a pointer, channel, func, interface, map, or slice type</span><br><span class="line"></span><br><span class="line">nil</span><br><span class="line">1.nil是空，并不一定是&quot;空指针&quot;</span><br><span class="line">2.nil是6种类型的&quot;零值&quot;</span><br><span class="line">3.每种类的nil是不同的，无法比较</span><br><span class="line"></span><br><span class="line">空结构体</span><br><span class="line">1.空结构体是Go中非常特殊的类型</span><br><span class="line">2.空结构体的值不是nil</span><br><span class="line">3.空结构体的指针也不是nil，但是都相同(zerobase)</span><br><span class="line"></span><br><span class="line">空接口</span><br><span class="line">func main() &#123;</span><br><span class="line">	var a interface&#123;&#125;</span><br><span class="line">	fmt.Println(a ==nil)</span><br><span class="line">	var c *int</span><br><span class="line">	a = c </span><br><span class="line">	//a:eface&#123;&#125; -&gt; _type = *int</span><br><span class="line">	fmt.Println(c ==nil)</span><br><span class="line">	fmt.Println(a ==nil)</span><br><span class="line">&#125;</span><br><span class="line">输出 true true false</span><br><span class="line">1.空接口不一定是&quot;nil接口&quot;</span><br><span class="line">2.两个属性都是nil才是nil接口（类型，数据）</span><br><span class="line"></span><br><span class="line">总结</span><br><span class="line">1.nil是多个类型的零值，或者空值</span><br><span class="line">2.空结构体的指针和值都不是nil</span><br><span class="line">3.空接口零值是nil，一旦有了类型信息就不是nil</span><br></pre></td></tr></table></figure>



<h4><span id="内存对齐">内存对齐</span></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">内存对齐：提高内存操作效率，有利于内存原子性</span><br><span class="line"></span><br><span class="line">对齐系数</span><br><span class="line">1.为了方便内存对齐，Go提供给了对齐系数</span><br><span class="line">unsafe.Alignof()</span><br><span class="line">2.对齐系数的含义是：变量的内存地址必须被对齐系数整除</span><br><span class="line">3.如果对齐系数为4，表示变量内存地址必须是4的倍数</span><br><span class="line">(64位平台最大对齐系数是8，32位平台最大对齐系数是4)</span><br><span class="line">(string，slice，map的内存长度是16，24，8 对齐系数是8，8，8)</span><br><span class="line"></span><br><span class="line">结构体对齐*</span><br><span class="line">1.结构体对齐分内存对齐和结构体之间对齐</span><br><span class="line">2.内存对齐：考虑成员大小和成员的对齐系数</span><br><span class="line">3.结构体长度填充：考虑自身对齐系数和系统字长</span><br><span class="line"></span><br><span class="line">结构体内部对齐</span><br><span class="line">1.指的是结构体内部成员的相对位置(偏移量)</span><br><span class="line">2.每个成员的偏移量是自身大小与其对齐系数较小值的倍数</span><br><span class="line"></span><br><span class="line">结构体长度填充</span><br><span class="line">1.指的是结构体通过增加长度，对齐系统字长</span><br><span class="line">2.结构体长度是最大成员长度与系统字长较小的整数倍</span><br><span class="line"></span><br><span class="line">节约结构体空间</span><br><span class="line">可以尝试通过调整成员顺序，节约空间</span><br><span class="line">type Demo1 struct &#123; //32 8</span><br><span class="line">	a bool         //1 1  </span><br><span class="line">	b string       //16 8</span><br><span class="line">	c int16        //2 2</span><br><span class="line">&#125;</span><br><span class="line">type Demo2 struct &#123; //24 8</span><br><span class="line">	a bool</span><br><span class="line">	b string</span><br><span class="line">	c int16</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*结构体的对齐系数是其成员的最大对齐系数</span><br><span class="line"></span><br><span class="line">空结构体的对齐</span><br><span class="line">1.空结构体单独出现时，地址为zerobase</span><br><span class="line">2.空结构体出现在结构体中时，地址跟随前一个变量</span><br><span class="line">3.空结构体出现在结构体末尾时，需要补齐字长</span><br><span class="line"></span><br><span class="line">总结</span><br><span class="line">1.提高内存操作效率，变量之间需要内存对齐</span><br><span class="line">2.基本类型考虑对齐系数</span><br><span class="line">3.结构体既需要内存对齐，又需要外部填充对齐</span><br><span class="line">4.空结构体作为最后一个成员，需要填充对齐</span><br></pre></td></tr></table></figure>



<h3><span id="3goroutine协程">3.Goroutine协程</span></h3><h4><span id="协程和线程gm结构体">协程和线程(g,m结构体)</span></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">1.协程的底层结构(g)</span><br><span class="line">runtime中，协程的本质是一个g结构体</span><br><span class="line">·stack：堆栈地址</span><br><span class="line">·gobuf：目前程序运行现场</span><br><span class="line">·atomicstatus：协程状态</span><br><span class="line"> </span><br><span class="line">type stack struct &#123;</span><br><span class="line">	lo uintptr //指向协程栈的低地址</span><br><span class="line">	hi uintptr //   ————   高地址</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type gobuf struct &#123;</span><br><span class="line">	sp   uintptr   //StackPointer栈指针</span><br><span class="line">	pc   uintptr   //ProgramCounter程序计数器</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">2.线程的抽象</span><br><span class="line">runtime中将操作系统线程抽象为m结构体</span><br><span class="line">·g0：g0协程，操作调度器</span><br><span class="line">·curg：current g，目前显存运行的g</span><br><span class="line">·mOS：操作系统线程信息</span><br><span class="line"> </span><br><span class="line">总结</span><br><span class="line">1.协程的本质 是一个g结构体</span><br><span class="line">2.g结构体记录了协程栈、PC信息</span><br><span class="line">3.最简情况下，线程执行标准调度循环，执行协程</span><br></pre></td></tr></table></figure>



<h4><span id="线程循环">线程循环</span></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.操作系统并不知道Goroutine的存在</span><br><span class="line">2.操作系统线程执行一个调度循环，顺序执行Goroutine</span><br><span class="line">3.调度循环非常像线程池</span><br><span class="line"></span><br><span class="line">schedule-&gt; execute-&gt; G.fn()-&gt; goexit</span><br></pre></td></tr></table></figure>



<h4><span id="gmp调度模型">*GMP调度模型</span></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">线程循环的问题</span><br><span class="line">1.协程顺序指向，无法并发</span><br><span class="line">2.多线程并发时，会抢夺协程队列的全局锁</span><br><span class="line"></span><br><span class="line">p结构体</span><br><span class="line">type p struct &#123;</span><br><span class="line">	m        muintptr   </span><br><span class="line">	runqhead uint32</span><br><span class="line">	runqtail uint32</span><br><span class="line">	runq     [256]guintptr</span><br><span class="line">	runnext  guintptr</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P的作用</span><br><span class="line">1.M与G之间的中介</span><br><span class="line">2.P持有一些G，使每次获取G的时候不用从全局找</span><br><span class="line">3.大大减少了并发冲突的情况</span><br><span class="line"></span><br><span class="line">窃取式工作分配机构</span><br><span class="line">1.如果在本地或者全局队列中找不到G</span><br><span class="line">2.去别的P中&quot;偷&quot;</span><br><span class="line">3.增强了线程的利用率</span><br><span class="line"></span><br><span class="line">新建协程</span><br><span class="line">1.随机寻找P</span><br><span class="line">2.将新协程放入P的runnext(插队)</span><br><span class="line">3.若P本地队列满，放入全局队列</span><br></pre></td></tr></table></figure>



<h4><span id="协程饥饿问题">协程饥饿问题</span></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">切换时机</span><br><span class="line">1.主动挂起(runtime.gopark())</span><br><span class="line">业务方法-&gt; gopark()-&gt; schedule()</span><br><span class="line">2.系统调用完成时</span><br><span class="line">业务方法-&gt; entersyscall()-&gt; 系统调用-&gt; exitsyscall()-&gt;</span><br><span class="line">schedule()</span><br><span class="line"></span><br><span class="line">总结</span><br><span class="line">1.如果协程顺序执行，会有饥饿问题</span><br><span class="line">2.协程执行中间，将协挂起，执行其他协程</span><br><span class="line">3.完成系统调用时挂起，也可以主动挂起</span><br><span class="line">4.防止全局队列饥饿，本地队列随机抽取全局队列</span><br></pre></td></tr></table></figure>



<h4><span id="抢占式调度解决了什么问题">抢占式调度解决了什么问题</span></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">runtime.morestack()</span><br><span class="line">1.morestack的本意是检查协程栈是否有足够空间</span><br><span class="line">2.调用方法时，会被编译器插入morestack()</span><br><span class="line"></span><br><span class="line">标记抢占</span><br><span class="line">1.系统监控到Goroutine运行超过10ms</span><br><span class="line">2.将g.stackguard0置于0xfffffade</span><br><span class="line"> </span><br><span class="line">抢占</span><br><span class="line">执行morestack()时判断是否被抢占</span><br><span class="line">如果被抢占，回到schedule()</span><br><span class="line"></span><br><span class="line">基于信号的抢占式调度(线程信号)</span><br><span class="line"></span><br><span class="line">总结</span><br><span class="line">1.基于系统调用和主动挂起，协程可能无法调度</span><br><span class="line">2.基于协作的抢占式调度：业务主动调用morestack()</span><br><span class="line">3.基于信号的抢占式调度：强制线程调用doSigPreempt()</span><br></pre></td></tr></table></figure>



<h4><span id="协程过多">协程过多</span></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">处理方案</span><br><span class="line">1.优化业务逻辑</span><br><span class="line">2.利用channel的缓存区</span><br><span class="line">3.协程池</span><br><span class="line">4.调整系统资源</span><br><span class="line"></span><br><span class="line">利用channel的缓存区</span><br><span class="line">·channel缓存机构</span><br><span class="line">·启动协程前，向channel送入一个空结构体</span><br><span class="line">·协程结束，取出一个空结构体</span><br><span class="line"></span><br><span class="line">协程池(tunny)</span><br><span class="line">·预创建一定数量的协程</span><br><span class="line">·将任务送入协程池队列</span><br><span class="line">·协程池不断去除可用协程，执行任务</span><br><span class="line"></span><br><span class="line">慎用协程池</span><br><span class="line">1.Go语言的线程，已经相当于池化了</span><br><span class="line">2.二级池化会增加系统复杂度</span><br><span class="line">3.Go语言的初衷式希望协程即用即毁，不要池化</span><br></pre></td></tr></table></figure>



<h3><span id="4sync锁">4.sync(锁…)</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sync.Mutex 互斥锁</span><br><span class="line">sync.RWMutex 读写锁</span><br><span class="line">sync.WaitGroup 等待组</span><br><span class="line">sync.Once 初始化</span><br></pre></td></tr></table></figure>



<h4><span id="atomic操作">atomic操作</span></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">atomic操作</span><br><span class="line">·原子操作时一种硬件层面加锁的机制</span><br><span class="line">·保证操作一个变量的时候，其他协程/线程无法访问</span><br><span class="line">·只能用于简单变量的简单操作</span><br></pre></td></tr></table></figure>



<h4><span id="sema锁">*sema锁</span></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">sema锁</span><br><span class="line">·也叫做信号量锁/信号锁</span><br><span class="line">·核心是一个uint32值，含义是同时可并发的数量</span><br><span class="line">·每一个sema锁都对应一个SemaRoot结构体</span><br><span class="line">·SemaRoot中有一个平衡二叉树用于协程排队</span><br><span class="line"></span><br><span class="line">type semaRoot struct &#123;</span><br><span class="line">	lock  mutex</span><br><span class="line">	treap *sudog // root of balanced tree of unique waiters.</span><br><span class="line">	nwait uint32 // Number of waiters. Read w/o the lock.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sema操作(uint32&gt; 0)</span><br><span class="line">1.获取锁：uint32减一，获取成功</span><br><span class="line">2.释放锁：uint32加一，释放成功</span><br><span class="line"></span><br><span class="line">sema操作(uint32==0)</span><br><span class="line">1.获取锁：协程休眠，进入堆等待</span><br><span class="line">2.释放锁：从堆树中取出一个协程，唤醒</span><br><span class="line">（****6-2 重新看一遍）</span><br><span class="line"></span><br><span class="line">总结</span><br><span class="line">1.原子操作是一种硬件层面加锁的机制</span><br><span class="line">2.数据类型和操作类型有限制</span><br><span class="line">3.sema锁是runtime的常用工具</span><br><span class="line">4.sema经常被用作休眠队列</span><br></pre></td></tr></table></figure>



<h4><span id="互斥锁">互斥锁</span></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">type Mutex struct &#123;</span><br><span class="line">	state int32</span><br><span class="line">	sema  uint32</span><br><span class="line">&#125;</span><br><span class="line">const (</span><br><span class="line">    mutexLocked = 1 &lt;&lt; iota // 锁是否被持有 即是否已经锁住</span><br><span class="line">    mutexWoken // 是否有被唤醒的go程</span><br><span class="line">    mutexStarving //是否处于饥饿状态，此标记可以确保某些go程不会长久获取不到锁</span><br><span class="line">    mutexWaiterShift = iota // 目前等待锁的go程数量</span><br><span class="line"></span><br><span class="line">    starvationThresholdNs = 1e6 //进入饥饿状态的阈值时间 1ms</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">state: WaiterShift Starving Woken Locked 4位图</span><br><span class="line"></span><br><span class="line">正常模式 加锁</span><br><span class="line">·尝试CAS直接加锁</span><br><span class="line">·若无法直接获取，进行多次自旋尝试</span><br><span class="line">·多次尝试失败进入sema队列休眠</span><br><span class="line">0000-&gt;0001-&gt;1001 or-&gt;2001(两个休眠)</span><br><span class="line"></span><br><span class="line">正常模式 解锁</span><br><span class="line">·尝试CAS直接解锁</span><br><span class="line">·若发现有协程</span><br><span class="line">2001-&gt;2000-&gt;1000-&gt;</span><br><span class="line"></span><br><span class="line">总结</span><br><span class="line">·mutex正常模式：自旋加锁+sema休眠等待</span><br><span class="line">·mutex正常模式下，可能有锁饥饿的问题</span><br><span class="line"></span><br><span class="line">Mutex饥饿模式</span><br><span class="line"> 1.当前协程等待锁的时间超过1ms，切换到饥饿模式</span><br><span class="line"> 2.饥饿模式中，不自旋，新来的协程直接sema休眠</span><br><span class="line"> 3.饥饿模式中，被唤醒的协程直接获取锁</span><br><span class="line"> 4.没有协程在队列中继续等待时，回到正常模式</span><br><span class="line">  2100-&gt;1100-&gt;2101-&gt;</span><br><span class="line">  </span><br><span class="line"> 使用经验</span><br><span class="line"> 1.减少锁的使用时间</span><br><span class="line"> 2.善用defer确保锁的释放</span><br></pre></td></tr></table></figure>

<h4><span id="读写锁">读写锁</span></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">多个协程同时只读</span><br><span class="line">· 只读时，让其他人不能修改即可</span><br><span class="line">· 只读时，多协程可以共享读</span><br><span class="line">· 只读时，不需要互斥锁</span><br><span class="line">read锁共享锁 write互斥锁</span><br><span class="line"></span><br><span class="line">读写锁需求</span><br><span class="line">1.每个锁分为读锁和写锁，写锁互斥</span><br><span class="line">2.没有加写锁时，多个写成都可以加读写锁</span><br><span class="line">3.加了写锁时，无法加读锁，读协程排队等待</span><br><span class="line">4.加了读锁，写锁排队等待</span><br><span class="line"></span><br><span class="line">type RWMutex struct &#123;</span><br><span class="line">	w           Mutex  // 互斥锁作为写锁</span><br><span class="line">	writerSem   uint32 // 作为写协程队列</span><br><span class="line">	readerSem   uint32 // 作为读协程队列</span><br><span class="line">	readerCount int32  // 正值：正在读的协程 负值：加了写锁</span><br><span class="line">	readerWait  int32  // 写锁应该等待读协程个数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">—————————————————加写锁——————————————————</span><br><span class="line">1.加写锁：没有读协程</span><br><span class="line">w 🔒</span><br><span class="line">readerCount = -rwmutexMaxReaders</span><br><span class="line"></span><br><span class="line">2.加写锁：有读协程</span><br><span class="line">w </span><br><span class="line">readerCount = 3</span><br><span class="line">readerWait = 0</span><br><span class="line">--&gt;&gt;</span><br><span class="line">w 🔒 //这里指互斥锁不是写锁</span><br><span class="line">writerSem -&gt;g //写锁进入写队列排队，等三个读锁释放了才能唤醒</span><br><span class="line">readerCount = 3-rwmutexMaxReaders</span><br><span class="line">readerWait= 3</span><br><span class="line"></span><br><span class="line">加写锁</span><br><span class="line">1.先加mutex写锁，若已经被加写锁会阻塞等待</span><br><span class="line">2.将rederCount变成负值，阻塞读锁的获取</span><br><span class="line">3.计算需要等待多少个读协程释放</span><br><span class="line">4.如果需要等待读协程释放，陷入writerSem</span><br><span class="line"></span><br><span class="line">—————————————————解写锁——————————————————</span><br><span class="line">解写锁</span><br><span class="line">1.将rederCount变成正值，允许读锁的获取</span><br><span class="line">2.释放在readerSem中等待的读协程</span><br><span class="line">3.解锁mutex</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">—————————————————加读锁——————————————————</span><br><span class="line">加读锁</span><br><span class="line">1.将给readerCount无脑加一</span><br><span class="line">2.如果readerCount是正数，加锁成功</span><br><span class="line">3.如果readerCount是负数，说明被加了写锁，陷入readerSem</span><br><span class="line"></span><br><span class="line">—————————————————解读锁——————————————————</span><br><span class="line">解读锁</span><br><span class="line">1.给readerCount减一</span><br><span class="line">2.如果readerCount是正数，解锁成功</span><br><span class="line">3.如果readerCount是负数，有写锁在排队</span><br><span class="line">  如果自己是readerWait的最后一个，唤醒写协程</span><br><span class="line"></span><br><span class="line">总结</span><br><span class="line">·Mutex用来写协程之间互斥等待</span><br><span class="line">·读协程使用readerSem等待写锁的释放</span><br><span class="line">·写协程使用writerSem等待读锁的释放</span><br><span class="line">·readerCount记录读协程个数</span><br><span class="line">·readerWait记录写协程之前的读协程个数</span><br></pre></td></tr></table></figure>



<h4><span id="waitgroup">WaitGroup</span></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">需求：实际业务中，一个(组)协程需要等待另一组协程完成</span><br><span class="line"></span><br><span class="line">type WaitGroup struct &#123;</span><br><span class="line">	noCopy noCopy</span><br><span class="line">	</span><br><span class="line">	state1 uint64</span><br><span class="line">	// 64位值：高32位是计数器，低32位是等待器计数。协程xx</span><br><span class="line">	// counter + waiter (=statep)</span><br><span class="line">	state2 uint32</span><br><span class="line">	// sema锁 装载等待的协程</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wait() 逻辑</span><br><span class="line">1.如果被等待的协程没了，直接返回</span><br><span class="line">2.否则，waiter加一，陷入sema</span><br><span class="line"></span><br><span class="line">v := int32(state &gt;&gt; 32) //counter</span><br><span class="line">w := uint32(state)  //waiter</span><br><span class="line"></span><br><span class="line">Done() 逻辑</span><br><span class="line">1.被等待协程做完，给counter减一</span><br><span class="line">2.通过Add(-1)实现</span><br><span class="line"></span><br><span class="line">Add() 逻辑</span><br><span class="line">1.add counter</span><br><span class="line">2.被等待协程没做完，或者没人在等待，返回</span><br><span class="line">3.被等待协程都做完，且有人在等待，唤醒所有sema中的协程</span><br><span class="line"></span><br><span class="line">总结</span><br><span class="line">·WaitGroup实现了一组协程等待另一组协程</span><br><span class="line">·等待的协程陷入sema并记录个数</span><br><span class="line">·被等待的协程计数归零时，唤醒所有sema中的协程</span><br></pre></td></tr></table></figure>

<h4><span id="once">Once</span></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">type Once struct &#123;</span><br><span class="line">	done uint32</span><br><span class="line">	m    Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">1.先判断是否已经改值</span><br><span class="line">2.没改，尝试获取锁</span><br><span class="line">3.获取到锁的协程执行业务，改值，解锁</span><br><span class="line">4.冲突协程唤醒后直接返回</span><br><span class="line"></span><br><span class="line">总结</span><br><span class="line">·sync.Once实现了一段代码只执行一次</span><br><span class="line">·使用标志+mutex实现并发冲突的优化</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4><span id="锁常见问题">锁常见问题</span></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1.锁拷贝问题</span><br><span class="line">·锁拷贝可能导致锁的死锁问题</span><br><span class="line">·使用vet工具可以检测锁拷贝问题</span><br><span class="line">·vet还能检测可能的bug或者可以的构造</span><br><span class="line">go vet main.go</span><br><span class="line"></span><br><span class="line">2.RACE竞争检测</span><br><span class="line">·发现隐含的数据竞争问题</span><br><span class="line">·可能是加锁的建议</span><br><span class="line">·可能是bug的提醒</span><br><span class="line">go build -race main.go</span><br><span class="line">./main</span><br><span class="line"></span><br><span class="line">3.go-deadlock检测</span><br><span class="line">·检测可能的死锁</span><br><span class="line">·实际是检测获取锁的等待时间</span><br><span class="line">·用来检查bug和性能问题</span><br><span class="line">https://github.com/sasha-s/go-deadlock</span><br><span class="line"></span><br><span class="line">总结</span><br><span class="line">·go vet检测bug或者可疑的构造</span><br><span class="line">·race发现隐含的数据竞争问题</span><br><span class="line">·go-deadlock检测可能的死锁</span><br></pre></td></tr></table></figure>



<h3><span id="5channel">5.Channel</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">channel基本用法</span><br><span class="line">· ch&lt;-x  //发送数据x</span><br><span class="line">· x=&lt;-ch //接收数据，赋给x</span><br><span class="line">· &lt;-ch   //接收数据，并丢弃</span><br></pre></td></tr></table></figure>

<h4><span id="内存与通信">内存与通信</span></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;不要通过共享内存的方式进行通信&quot;</span><br><span class="line">&quot;而是应该通过通信的方式共享内存&quot;</span><br><span class="line"></span><br><span class="line">why</span><br><span class="line">1.避免协程竞争和数据冲突的问题</span><br><span class="line">2.更高级的抽象，降低开发难度，增加程序可读性</span><br><span class="line">3.模块之间更容易解耦，增强扩展性和可维护性</span><br></pre></td></tr></table></figure>



<h4><span id="底层结构">底层结构</span></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">type hchan struct &#123;</span><br><span class="line">	qcount   uint           </span><br><span class="line">	dataqsiz uint           </span><br><span class="line">	buf      unsafe.Pointer </span><br><span class="line">	elemsize uint16</span><br><span class="line">	closed   uint32</span><br><span class="line">	elemtype *_type </span><br><span class="line">	sendx    uint   // send index</span><br><span class="line">	recvx    uint   // receive index</span><br><span class="line">	recvq    waitq  // list of recv waiters</span><br><span class="line">	sendq    waitq  // list of send waiters</span><br><span class="line"></span><br><span class="line">	lock mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type waitq struct &#123;</span><br><span class="line">	first *sudog</span><br><span class="line">	last  *sudog</span><br><span class="line">&#125; //链表</span><br><span class="line"></span><br><span class="line">·缓冲区(环形缓存 Ring Buffer)</span><br><span class="line"> qcount   uint           </span><br><span class="line"> dataqsiz uint           </span><br><span class="line"> buf      unsafe.Pointer </span><br><span class="line"> elemsize uint16</span><br><span class="line"> elemtype *_type </span><br><span class="line">环形缓存可以大幅降低GC的开销</span><br><span class="line"></span><br><span class="line">·两个队列(Send Queue/Receive ~)</span><br><span class="line"> sendx    uint   </span><br><span class="line"> sendq    waitq  </span><br><span class="line"> </span><br><span class="line"> recvx    uint   </span><br><span class="line"> recvq    waitq  </span><br><span class="line"> </span><br><span class="line">·互斥锁(Mutex)</span><br><span class="line">1.互斥锁并不是排队发送/接收数据</span><br><span class="line">2.互斥锁保护的hchan结构体本身</span><br><span class="line">3.Channel并不是无锁的</span><br><span class="line"></span><br><span class="line">·状态值(closed)</span><br><span class="line"> ·0为开启</span><br><span class="line"> ·1为关闭</span><br><span class="line"></span><br><span class="line">总结</span><br><span class="line">&quot;Channel是go的一等公民&quot;</span><br></pre></td></tr></table></figure>



<h4><span id="clt-和lt-c关键字">c&lt;- 和&lt;-c关键字</span></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">·c&lt;-和 &lt;-c关键字是一个语法糖</span><br><span class="line"></span><br><span class="line">·编译阶段，会把c&lt;-转化为runtime.chansend1()</span><br><span class="line">·chansend1()会调用chansend()方法</span><br><span class="line"></span><br><span class="line">·编译阶段，i&lt;-c 转化为runtime.chanrecv1()</span><br><span class="line">·编译阶段，i,ok&lt;-c转为runtime.chanrecv2()</span><br><span class="line">·最后会调用chanrecv()方法</span><br></pre></td></tr></table></figure>



<h4><span id="channel发送数据的底层原理">Channel发送数据的底层原理</span></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Channel发送的情况</span><br><span class="line">1.直接发送</span><br><span class="line">2.放入缓存</span><br><span class="line">3.休眠等待</span><br><span class="line"></span><br><span class="line">直接发送(原理)</span><br><span class="line">1.发送数据前，已经有G在休眠等待接收</span><br><span class="line">2.此时缓存肯定是空的，不用考虑缓存</span><br><span class="line">3.将数据直接拷贝给G的结束变量，唤醒G</span><br><span class="line">直接发送(实现)</span><br><span class="line">1.从队列里取出一个等待接收的G</span><br><span class="line">2.将数据直接拷贝到接收变量中</span><br><span class="line">3.唤醒G</span><br><span class="line"></span><br><span class="line">放入缓存(原理)</span><br><span class="line">1.没有G在休眠等待，但是有缓存空间</span><br><span class="line">2.将数据放入缓存</span><br><span class="line">放入缓存(实现)</span><br><span class="line">1.获取可存入的缓存地址</span><br><span class="line">2.存入数据</span><br><span class="line">3.维护索引</span><br><span class="line"></span><br><span class="line">休眠等待(原理)</span><br><span class="line">1.没有G在休眠等待，而且没有缓存或满了</span><br><span class="line">2.自己进入发送队列，休眠等待</span><br><span class="line">休眠等待(实现)</span><br><span class="line">1.把自己包装成sudog</span><br><span class="line">2.sudug放入sendq队列</span><br><span class="line">3.休眠并解锁</span><br><span class="line">4.被唤醒后，数据已经被取走，维护其他数据</span><br><span class="line"></span><br><span class="line">总结</span><br><span class="line">1.直接发送时，将数据直接拷贝到目标变量</span><br><span class="line">2.放入缓存时，将数据放入环形缓存，成功放回</span><br><span class="line">3.休眠等待时，将自己包装后放入sendq，休眠</span><br></pre></td></tr></table></figure>



<h4><span id="channel接收数据的底层原理">Channel接收数据的底层原理</span></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">Channel接收的情况</span><br><span class="line">1.有等待的G，从G接收</span><br><span class="line">2.有等待的G，从缓存接收</span><br><span class="line">3.接收缓存</span><br><span class="line">4.阻塞接收</span><br><span class="line"></span><br><span class="line">有等待的G，从G接收(原理)</span><br><span class="line">1.接受数据前,已经有G在休眠等待发送</span><br><span class="line">2.而且这个Channel没有缓存</span><br><span class="line">3.将数据直接从G拷贝过来，唤醒G</span><br><span class="line">有等待的G，从G接收(实现)</span><br><span class="line">1.判断有G在发送队列等待，进入recv()</span><br><span class="line">2.判断次Channel无缓存</span><br><span class="line">3.直接从等待的G中取走数据，唤醒G</span><br><span class="line"></span><br><span class="line">有等待的G，从缓存接收(原理)</span><br><span class="line">1.接收数据前,已经有G在休眠等待发送</span><br><span class="line">2.而且这个Channel有缓存</span><br><span class="line">3.从缓存取走一个数据</span><br><span class="line">4.将休眠G的数据放进缓存,唤醒G</span><br><span class="line">有等待的G，从缓存接收(实现)</span><br><span class="line">1.判断有G在发送队列等待，进入recv()</span><br><span class="line">2.判断此Channel有缓存</span><br><span class="line">3.从缓存中取走一个数据</span><br><span class="line">4.将G的数据放入缓存，唤醒G</span><br><span class="line"></span><br><span class="line">接收缓存(原理)</span><br><span class="line">1.没有G在休眠等待发送，但是缓存有内容</span><br><span class="line">2.从缓存取走数据</span><br><span class="line">接收缓存(实现)</span><br><span class="line">1.判断没有G在发送队列等待</span><br><span class="line">2.判断此Channel有缓存</span><br><span class="line">3.从缓存中取走一个数据</span><br><span class="line"></span><br><span class="line">阻塞接收(原理)</span><br><span class="line">1.没有G在休眠等待，而且没有缓存或缓存空间</span><br><span class="line">2.自己进入接收队列，休眠等待</span><br><span class="line">阻塞接收(实现)</span><br><span class="line">1.判断没有G在发送队列等待</span><br><span class="line">2.判断此Channel无缓存</span><br><span class="line">3.将自己包装成sudog</span><br><span class="line">4.sudog放入接收等待队列，休眠</span><br><span class="line">5.唤醒时，发送的G已经把数据拷贝到位</span><br><span class="line"></span><br><span class="line">总结</span><br><span class="line">1.有等待的G，且无缓存时，从G接收</span><br><span class="line">2.有等待的G，且有缓存时，从缓存接收</span><br><span class="line">3.无等待的G，且缓存有数据，从缓存接收</span><br><span class="line">4.无等待的G，且缓存无数据，等待喂数据</span><br></pre></td></tr></table></figure>



<h4><span id="非阻塞的channelselecttimer">非阻塞的Channel(select,timer)</span></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">select原理</span><br><span class="line">·同时存在接收，发送，默认路径</span><br><span class="line">·首先查看是否有可以即时执行的case</span><br><span class="line">·没有的话，有default，走default</span><br><span class="line">·没有default,把自己注册在所有的channel中，休眠等待</span><br><span class="line"></span><br><span class="line">timer</span><br><span class="line"></span><br><span class="line">type Timer struct &#123;</span><br><span class="line">	C &lt;-chan Time</span><br><span class="line">	r runtimeTimer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="6tcp网路编程">6.TCP网路编程</span></h3><h4><span id="io模型">IO模型</span></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">IO模型指的是同时操作Socket的方案</span><br><span class="line">·阻塞</span><br><span class="line">·非阻塞</span><br><span class="line">·多路复用</span><br><span class="line"></span><br><span class="line">阻塞IO</span><br><span class="line">1.同步读写Socket时，线程陷入内核态</span><br><span class="line">2.当读写成功后，切换回用户态，继续执行</span><br><span class="line">3.优点：开发难度小，代码简单</span><br><span class="line">4.缺点：内核态切换开销大</span><br><span class="line"></span><br><span class="line">非阻塞IO</span><br><span class="line">1.如果暂时无法收发数据，会返回错误</span><br><span class="line">2.应用会不断轮询，直到Socket可以读写</span><br><span class="line">3.优点：不会陷入内核态，自由度高</span><br><span class="line">4.缺点：需要自旋轮询</span><br><span class="line"></span><br><span class="line">多路复用(linux epoll)</span><br><span class="line">epoll=event poll事件池</span><br><span class="line">1.注册多个Socket事件</span><br><span class="line">2.调用epool，当有事件发生，返回</span><br><span class="line">3.优点：提供了事件列表，不需要查询各个Socket</span><br><span class="line">4.缺点：开发难度大，逻辑复杂</span><br><span class="line">5.Mac:kqueue; Windows:IOCP</span><br><span class="line"></span><br><span class="line">总结</span><br><span class="line">1.操作系统提供了Socket作为TCP通信的抽象</span><br><span class="line">2.IO模型指的是操作Socket的方案</span><br><span class="line">3.阻塞模型最利于业务编写，但是性能差</span><br><span class="line">4.多路复用性能好，但业务编写麻烦</span><br></pre></td></tr></table></figure>



<h4><span id="go抽象epoll">go抽象epoll</span></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">阻塞模型+多路复用</span><br><span class="line">·在底层使用操作系统的多路复用IO</span><br><span class="line">·在协程层次使用阻塞模型</span><br><span class="line">·阻塞协程时，休眠协程</span><br><span class="line"></span><br><span class="line">epoll抽象层</span><br><span class="line">epoll抽象层是为了统一各个操作系统对多路复用器的实现</span><br><span class="line">Linux:Epoll</span><br><span class="line">Windows:IOCP</span><br><span class="line">Mac:Kqueue</span><br><span class="line"></span><br><span class="line">多路复用器</span><br><span class="line">各个系统的多路复用都有以下功能：</span><br><span class="line">  新建多路复用器epoll_create()</span><br><span class="line">  往多路复用器里插入需要监听的事件epoll_ctl()</span><br><span class="line">  查询发生了什么时间epoll_wait()</span><br><span class="line">  </span><br><span class="line">·go Network Poller对于多路复用器的抽象和适配</span><br><span class="line">·epoll_create() -&gt; netpollinit()</span><br><span class="line">·epoll_ctL() -&gt; netpollopen()</span><br><span class="line">·epoll_wait() -&gt; netpoll()</span><br><span class="line"></span><br><span class="line">TODO go抽象netpoll 略 8-4</span><br></pre></td></tr></table></figure>

<h4><span id="socket">Socket</span></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">net.Listen()</span><br><span class="line">·新建Socket，并执行bind操作</span><br><span class="line">·新建一个FD(net包对Socket的详情描述)</span><br><span class="line">·返回一个TCPListener对象</span><br><span class="line">·将TCPListener的FD信息加入监听</span><br><span class="line">·TCPListener对象本质上是一个LISTEN状态的Socket</span><br><span class="line"></span><br><span class="line">TCPListener.Accept()</span><br><span class="line">·直接调用Socket的accept()</span><br><span class="line">·如果失败，休眠等待新饿连接</span><br><span class="line">·将新的Socket包装为TCPConn变量返回</span><br><span class="line">·将TCPConn的FD信息加入监听</span><br><span class="line">·TCPConn本质上是一个ESTABLISHED状态额Socket</span><br><span class="line"></span><br><span class="line">TCPConn.Read()/Write()</span><br><span class="line">·直接调用Socket原生读写方法</span><br><span class="line">·如果失败，休眠等待可读/可写</span><br><span class="line">·被唤醒后调用系统Socket</span><br><span class="line"></span><br><span class="line">总结</span><br><span class="line">1.net包抽象了TCP网络操作</span><br><span class="line">2.使用net.Listen()得到TCPListener(LISTEN状态的Socket)</span><br><span class="line">3.使用TCPListener.Accept()得到TCPConn(ESTABLISHED)</span><br><span class="line">4.TCPConn.Read()/Write()进行读写Socket的操作</span><br><span class="line">5.Network Poller 作为上述功能的底层支撑</span><br><span class="line"></span><br><span class="line">TODO socket在go里的抽象代码 略</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4><span id="结合阻塞模型和多路复用">结合阻塞模型和多路复用</span></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">思路</span><br><span class="line">1.用主协程监听Listener</span><br><span class="line">2.每个Conn使用一个新协程处理</span><br></pre></td></tr></table></figure>



<h3><span id="7内存模型与垃圾回收">7.内存模型与垃圾回收</span></h3><h4><span id="协程栈">协程栈</span></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Go协程栈的作用</span><br><span class="line">1.协程的执行路径</span><br><span class="line">2.局部变量</span><br><span class="line">3.函数传参</span><br><span class="line">4.函数返回值</span><br><span class="line"></span><br><span class="line">Go协程栈的位置</span><br><span class="line">·Go协程栈位于Go堆内存上</span><br><span class="line">·Go堆内存位于操作系统虚拟内存上</span><br><span class="line"></span><br><span class="line">参数传递</span><br><span class="line">*·Go使用参数拷贝传递(值传递)</span><br><span class="line">·传递结构体时：会拷贝结构体中的全部内容</span><br><span class="line">·传递指针时，会拷贝结构体指针</span><br><span class="line"></span><br><span class="line">总结</span><br><span class="line">1.协程栈记录了协程的执行线程</span><br><span class="line">2.协程栈还赋值记录局部变量，传递参数和返回值</span><br><span class="line">3.Go使用参数拷贝传递</span><br><span class="line"></span><br><span class="line">思考</span><br><span class="line">协程栈不够大怎么办</span><br><span class="line">·局部变量太大-&gt;逃逸分析</span><br><span class="line">·栈帧太多-&gt;栈扩容</span><br></pre></td></tr></table></figure>



<h4><span id="逃逸分析">逃逸分析</span></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">逃逸分析</span><br><span class="line">1.不是所有的变量都能放在协程栈上</span><br><span class="line">2.栈帧回收后，需要继续使用的变量</span><br><span class="line">3.太大的变量</span><br><span class="line"></span><br><span class="line">三种逃逸</span><br><span class="line">·指针逃逸</span><br><span class="line"> 函数返回了对象的指针</span><br><span class="line"> </span><br><span class="line">·空接口逃逸</span><br><span class="line"> 如果函数参数为interface&#123;&#125;</span><br><span class="line"> 函数参数很可能会逃逸</span><br><span class="line"> 因为interface&#123;&#125;类型的函数往往会使用反射</span><br><span class="line"> </span><br><span class="line">·大变量逃逸</span><br><span class="line"> 过大的变量会导致栈空间不足</span><br><span class="line"> 64位机器中，一般超过64kb的变量会逃逸</span><br></pre></td></tr></table></figure>



<h4><span id="栈扩容">栈扩容</span></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">栈扩容</span><br><span class="line"> 1.Go栈的初始空间为2kb</span><br><span class="line"> 2.在函数调用前判断栈空间(morestack)</span><br><span class="line"> 3.必要时对栈进行扩容</span><br><span class="line"> 4.早期使用分段栈，后期使用连续段</span><br><span class="line"> </span><br><span class="line"> 分段栈(1.13之前使用)</span><br><span class="line"> 优点：没有空间浪费</span><br><span class="line"> 缺点：栈指针会在不连续的空间跳转</span><br><span class="line"> </span><br><span class="line"> 连续栈</span><br><span class="line"> 优点：空间一直连续</span><br><span class="line"> 缺点：伸缩时的开销大</span><br><span class="line"> 当空间不足时扩容，变为原来的2倍</span><br><span class="line"> 当空间使用率不足1/4时缩容，变成原来的1/2</span><br></pre></td></tr></table></figure>



<h4><span id="堆内存结构">堆内存结构</span></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">操作系统虚拟内存</span><br><span class="line">1.不是Win的&quot;虚拟内存&quot;</span><br><span class="line">2.操作系统给应用提供的虚拟内存空间</span><br><span class="line">3.背后是物理内存，也有可能是磁盘</span><br><span class="line">4.Linux获取虚拟内存：mmap，madvice</span><br><span class="line"></span><br><span class="line">heapArena</span><br><span class="line">1.Go每次申请的虚拟内存单位为64MB</span><br><span class="line">2.最多又4194304个虚拟内存单位(2^20)</span><br><span class="line">3.内存单位也叫heapArena</span><br><span class="line">4.所有的heapArena组成了mheap(Go堆内存)</span><br><span class="line"></span><br><span class="line">内存管理单元mspan</span><br><span class="line">1.根据隔离适应策略，使用内存时的最小单元为mspan</span><br><span class="line">2.每个mspan为N个相同大小的&quot;格子&quot;</span><br><span class="line">3.Go中一共有67种mspan</span><br><span class="line"></span><br><span class="line">中心索引mcentral</span><br><span class="line"> ·136个mcentral结构体，其中</span><br><span class="line"> ·68个组需要GC扫描的mspan</span><br><span class="line"> ·68个组不需要GC扫描的mspan</span><br><span class="line"> </span><br><span class="line">mcentral的性能问题</span><br><span class="line">1.mcentral实际是中心索引，使用互斥锁保护</span><br><span class="line">2.在高并发场景下，锁冲突问题严重</span><br><span class="line">3.参考协程GMP模型，增加线程本地缓冲</span><br><span class="line"></span><br><span class="line">线程缓冲mcache</span><br><span class="line">·每个P拥有一个mcache</span><br><span class="line">·一个mcache拥有136个mspan，其中</span><br><span class="line">·68个组需要GC扫描的mspan</span><br><span class="line">·68个组不需要GC扫描的mspan</span><br><span class="line"></span><br><span class="line">总结</span><br><span class="line">·Go模仿TCmalloc，建立了自己的堆内存结构</span><br><span class="line">·使用heapArena向操作系统申请内存</span><br><span class="line">·使用heapArena时，以mspan为单位，防止碎片化</span><br><span class="line">·mcentral是mspan们的中心索引</span><br><span class="line">·mcache记录了分配给各个P的本地mspan</span><br></pre></td></tr></table></figure>

<h4><span id="堆内存分配">堆内存分配</span></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">对象分级</span><br><span class="line">1.Tiny微对象(0,16B)无指针</span><br><span class="line">2.small小对象[16B,32KB]</span><br><span class="line">3.Large大对象(32KB,+♾️)</span><br><span class="line"> ·微小对象分配至普通mspan</span><br><span class="line"> ·大对象量身定做mspan</span><br><span class="line"> </span><br><span class="line">微对象分配</span><br><span class="line">1.从mcache拿到2级mspan</span><br><span class="line">2.将多个微对象合并成一个16Byte存入</span><br><span class="line"></span><br><span class="line">mcache的替换</span><br><span class="line">1.mache中，每个级别的mspan只有一个</span><br><span class="line">2.当mpan满了之后，会从mcentral中换一个新的</span><br><span class="line"></span><br><span class="line">mcentral的扩容</span><br><span class="line">1.mcentral中，只有有限数量的mspan</span><br><span class="line">2.当mspan缺少时，会从heapArena开辟新的mspan </span><br><span class="line"></span><br><span class="line">大对象分配</span><br><span class="line">1.直接从heapArena开辟0级的mspan</span><br><span class="line">2.0级的mspan为大对象定制</span><br><span class="line"></span><br><span class="line">heapArena的扩容</span><br><span class="line">1.当heapArena空间不足时</span><br><span class="line">2.向操作系统申请新的heapArena</span><br><span class="line"></span><br><span class="line">总结</span><br><span class="line">1.Go将对象按照大小分为3种</span><br><span class="line">2.微小对象使用mcache</span><br><span class="line">3.mcache的mspan填满后，与mcentral交换新的(避免了🔒的情况)</span><br><span class="line">4.mcentral不足时，在heapArena开辟新的mspan</span><br><span class="line">5.大对象直接在heapArena开辟新的mspan</span><br></pre></td></tr></table></figure>

<h4><span id="垃圾回收">垃圾回收</span></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">GC思路</span><br><span class="line"> ·&quot;标记-清除&quot;</span><br><span class="line"> ·&quot;标记-整理&quot;</span><br><span class="line"> ·&quot;复制&quot;</span><br><span class="line"> (后两种java用的多)</span><br><span class="line">1.Go因为堆内存结构的独特优势，选择最简单的标记-清除</span><br><span class="line">2.找到有引用的对象，剩下就是没用的</span><br><span class="line"></span><br><span class="line">Root Set(Gc Root)</span><br><span class="line">1.被栈上的指针引用</span><br><span class="line">2.被全局变量引用</span><br><span class="line">3.被寄存器中的指针引用</span><br><span class="line">Root节点进行广度优先搜索DFS，这种方法也叫可达性分析标记法</span><br><span class="line"></span><br><span class="line">串行GC步骤 </span><br><span class="line">(go已经不这样做了，STW对性能影响大)</span><br><span class="line">1.Stop The World，暂停所有其他协程</span><br><span class="line">2.通过可达性分析，找到无用的堆内存</span><br><span class="line">3.释放堆内存</span><br><span class="line">4.恢复所有其他协程</span><br><span class="line"></span><br><span class="line">总结</span><br><span class="line">·从GC Root出发，寻找引用对象</span><br><span class="line">·没有被引用的就是无用对象</span><br><span class="line">·串行GC需要STW，对性能影响大</span><br><span class="line">——————————————————————————————</span><br><span class="line">并发垃圾回收</span><br><span class="line"></span><br><span class="line">三色标记法</span><br><span class="line"> ·黑色：有用，已经分析扫描</span><br><span class="line"> ·灰色：有用，还未分析扫描</span><br><span class="line"> ·白色：暂时无用</span><br><span class="line"> </span><br><span class="line">1.起初所有的对象都是白色</span><br><span class="line">2.从根对象出发扫描可达对象，标记为灰色</span><br><span class="line">3.扫描灰色对象，将其引用的对象标记为灰色，自身标记为黑色</span><br><span class="line">4.清除白色对象(结束只有黑色)</span><br><span class="line">5.再次标记时，所有对象恢复为白色</span><br><span class="line"></span><br><span class="line">并发标记问题(删除and插入)</span><br><span class="line">1.并发标记进行中</span><br><span class="line"></span><br><span class="line">Yuasa删除屏障</span><br><span class="line"> ·删除屏障可以杜绝在GC标记中被释放的指针，被清理</span><br><span class="line">Dijkstra插入屏障</span><br><span class="line"> ·并发标记时</span><br><span class="line"> ·对指针新指向的白色对象置灰</span><br><span class="line"> ·插入屏障可以杜绝在GC标记中被插入的指针，被清理</span><br><span class="line"> </span><br><span class="line">混合屏障(golang)</span><br><span class="line">1.被删除的堆对象标记为灰色</span><br><span class="line">2.被添加的堆对象标记为灰色</span><br><span class="line"></span><br><span class="line">总结</span><br><span class="line">1.并发垃圾回收的关键在于标记安全</span><br><span class="line">2.混合屏障机制兼顾了安全与效率</span><br></pre></td></tr></table></figure>

<h4><span id="优化gc效率">优化GC效率</span></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">GC触发的时机</span><br><span class="line">1.系统定时触发</span><br><span class="line">2.用户显式触发</span><br><span class="line">3.申请内存时触发</span><br><span class="line"></span><br><span class="line">系统定时触发</span><br><span class="line"> ·sysmon定时检查</span><br><span class="line"> ·如果2分钟内没有GC，触发</span><br><span class="line"> ·谨慎调整</span><br><span class="line"> </span><br><span class="line">用户显示触发</span><br><span class="line"> ·用户调用runtime.GC方法</span><br><span class="line"> ·并不推荐调用</span><br><span class="line"> </span><br><span class="line">申请内存时触发</span><br><span class="line"> ·给对象申请堆内存时，可能导致GC</span><br><span class="line">  runtime.mallocgc()</span><br><span class="line">  </span><br><span class="line">GC优化原则</span><br><span class="line"> 尽量少在堆上产生垃圾</span><br><span class="line">  ·内存池化</span><br><span class="line">  ·减少逃逸</span><br><span class="line">  ·使用空结构体</span><br><span class="line">  </span><br><span class="line">内存池化</span><br><span class="line"> ·缓存性质的对象</span><br><span class="line"> ·频繁创建喝删除</span><br><span class="line"> ·使用内存池，不GC</span><br><span class="line">减少逃逸</span><br><span class="line"> ·逃逸会使原本在栈上的对象进入堆中</span><br><span class="line"> ·fmt包</span><br><span class="line"> ·返回了指针而不是拷贝</span><br><span class="line">使用空结构体</span><br><span class="line"> ·空结构体指向一个固定地址</span><br><span class="line"> ·不占用堆空间</span><br><span class="line"> ·比如channel传递空结构体</span><br><span class="line"> </span><br><span class="line">GC分析工具</span><br><span class="line">1.go tool pprof</span><br><span class="line">2.go tool trace</span><br><span class="line">3.go build -gcflags=&quot; -m&quot;</span><br><span class="line">4.GODEBUG=&quot; gctrace=1&quot;(推荐)</span><br></pre></td></tr></table></figure>



<h3><span id="8go的其他高级特性">8.Go的其他高级特性</span></h3><h4><span id="go调用c代码cgo">go调用c代码(cgo)</span></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">int sum(int a, int b)&#123;</span><br><span class="line">	return a+b;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line">import &quot;C&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	println(C.sum(1, 1))</span><br><span class="line">&#125;</span><br><span class="line">——————————————————————————————</span><br><span class="line">go tool cgo main.go</span><br><span class="line">原理</span><br><span class="line">1.在内存中开辟一个结构体</span><br><span class="line">2.结构体中含有参数和返回值</span><br><span class="line">3.结构体地址传入C方法</span><br><span class="line">4.C方法将结构写入返回值的位置</span><br><span class="line"></span><br><span class="line">调度器的配合</span><br><span class="line">1.协程需要抢占式调度</span><br><span class="line">2.进入C程序之后，调度器无法抢占协程</span><br><span class="line">3.调度器停止对此协程的调度</span><br><span class="line"></span><br><span class="line">协程栈的切换</span><br><span class="line">1.C的栈不受Runtime管理</span><br><span class="line">2.进入C时，需要将当前栈切换到线程的系统栈上</span><br><span class="line"></span><br><span class="line">cgo的优缺点</span><br><span class="line">1.cgo可以让go调用现成的C实现</span><br><span class="line">2.cgo限制了go语言的跨平台特性</span><br><span class="line">3.cgo并不能提高Go语言的性能</span><br><span class="line"></span><br><span class="line">总结</span><br><span class="line">1.cgo是让go语言调用C方法的技术</span><br><span class="line">2.cgo需要go调度器和协程栈的配合</span><br><span class="line">3.cgo一般用于找不到go实现的情况</span><br><span class="line">4.cgo不能提高性能，是一个临时解决方案</span><br></pre></td></tr></table></figure>



<h4><span id="defer底层原理">defer底层原理</span></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">思路</span><br><span class="line">1.协程记录defer信息，函数退出时调用</span><br><span class="line">2.将defer代码直接编译进函数尾</span><br><span class="line"></span><br><span class="line">思路1 堆上分配</span><br><span class="line">1. 1.12之前使用</span><br><span class="line">2.在堆上开辟一个sched.deferpool</span><br><span class="line">3.遇到defer语句，将信息放入deferpool</span><br><span class="line">4.函数返回时，从deferpool取出执行</span><br><span class="line"></span><br><span class="line">思路2 栈上分配</span><br><span class="line">1. 1.13之后出现</span><br><span class="line">2.遇到derfer语句，将信息放入栈上</span><br><span class="line">3.函数返回时，从栈中取出执行</span><br><span class="line">4.只能保持一个defer信息</span><br><span class="line"></span><br><span class="line">思路3 开放编码</span><br><span class="line">1. 1.14之后出现</span><br><span class="line">2.如果defer语句在编译时就可以固定</span><br><span class="line">3.直接改写用户代码，defer语句放在函数末尾</span><br><span class="line"></span><br><span class="line">总结</span><br><span class="line">1.defer可以方便业务的编写</span><br><span class="line">2.defer有两种思路，三种实现</span><br><span class="line">3.性能最高的是开放编码法</span><br></pre></td></tr></table></figure>



<h4><span id="panic-defer-recover">panic + defer +recover</span></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	defer fmt.Println(&quot;defer main g&quot;)</span><br><span class="line"></span><br><span class="line">	go func() &#123;</span><br><span class="line">		defer func() &#123;</span><br><span class="line">			recover()</span><br><span class="line">		&#125;()</span><br><span class="line">		panic(&quot;&quot;)</span><br><span class="line">		fmt.Println(&quot;end g&quot;)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	fmt.Println(&quot;end main g&quot;)</span><br><span class="line">&#125;</span><br><span class="line">——————————————————————————————————————————</span><br><span class="line">panic基本使用</span><br><span class="line">1.panic会抛出错误</span><br><span class="line">2.终止协程运行</span><br><span class="line">3.带崩整个Go程序</span><br><span class="line"></span><br><span class="line">panic + defer</span><br><span class="line">1.panic在退出协程之前会执行所有已注册的defer</span><br><span class="line">2.不会执行其他协程的defer</span><br><span class="line"></span><br><span class="line">panic + defer +recover</span><br><span class="line"> 在defer中执行recover，可以拯救panic的协程</span><br><span class="line">原理</span><br><span class="line">1.如果设计recover，defer会使用堆上分配(deferpool)</span><br><span class="line">2.遇到panic，panic会从deferpool取出的defer语句，执行</span><br><span class="line">3.defer中调用recover，可以终止panic的过程</span><br><span class="line"></span><br><span class="line">总结</span><br><span class="line">1.panic终止当前协程的运行</span><br><span class="line">2.panic在退出协程之前会执行所有已注册的defer</span><br><span class="line">3.在defer中执行recover，可以拯救panic的协程</span><br></pre></td></tr></table></figure>

<h4><span id="reflect">reflect</span></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">需求</span><br><span class="line"> ·获取对象的类型</span><br><span class="line"> ·对任意类型变量赋值</span><br><span class="line"> ·调用任意方法</span><br><span class="line"> </span><br><span class="line">元数据</span><br><span class="line">1.元数据就是&quot;数据的数据&quot;</span><br><span class="line">2.把对象的类型表示成一个数据类型</span><br><span class="line">3.把对象的值表示成一个数据类型</span><br><span class="line"></span><br><span class="line">对象的类型</span><br><span class="line">1.接口reflect.Type</span><br><span class="line">2.把对象的类型表示成一个接口</span><br><span class="line">3.就能对类型坐各种操作</span><br><span class="line"></span><br><span class="line">对象的值</span><br><span class="line">1.结构体reflect.Value</span><br><span class="line">2.把对象的值表示成一个结构体</span><br><span class="line">3.就能对值做各种操</span><br><span class="line"></span><br><span class="line">使用反射调用方法</span><br><span class="line">1.通过反射调用方法，可以将框架和用户方法解耦</span><br><span class="line">2.往往需要用户注册方法，框架调用</span><br><span class="line">3.很多框架的HTTP调用处理使用此思路</span><br><span class="line">————————————————————————————————————————————</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;reflect&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func Dove1(a int, b int) int &#123;</span><br><span class="line">	return a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Dove2(a int, b int) int &#123;</span><br><span class="line">	return a - b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func CallAdd(f func(a int, b int) int) &#123;</span><br><span class="line">	v := reflect.ValueOf(f)</span><br><span class="line">	if v.Kind() != reflect.Func &#123;</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	argv := make([]reflect.Value, 2)</span><br><span class="line">	argv[0] = reflect.ValueOf(1)</span><br><span class="line">	argv[1] = reflect.ValueOf(2)</span><br><span class="line"></span><br><span class="line">	result := v.Call(argv)</span><br><span class="line">	fmt.Println(result[0].Int())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	CallAdd(Dove1)</span><br><span class="line">	CallAdd(Dove2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</div> 

<script>
    window.onload = detectors();
</script>
    <div class="post-footer">
    <div class="h-line-primary"></div>
    <nav class="post-nav">
        <div class="prev-item">
           
        </div>
        <div class="next-item">
            
                <div class="icon arrow-right"></div>
                <div class="post-link">
                  <a href="/2022/04/18/%E8%B0%88%E4%B8%80%E8%B0%88golang%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E4%B8%89%E7%A7%8D%E5%B5%8C%E5%A5%97%E5%8F%8A%E5%8C%BF%E5%90%8D%E5%AD%97%E6%AE%B5/">Next</a>  
                </div>  
            
        </div>
    </nav>
</div>

    
      <div class="post-comment">

     

     
    
    

</div>
     
  

</article>
        </div>
      </div>
      
      <div class="footer">
    <div class="flex-container">
        <div class="footer-text">
            
            
            
                Powered by <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> & <a target="_blank" rel="noopener" href="https://github.com/zoeingwingkei/frame/">Frame</a>
                
        </div>
    </div>
</div>

    </div>

  </body>
</html>
